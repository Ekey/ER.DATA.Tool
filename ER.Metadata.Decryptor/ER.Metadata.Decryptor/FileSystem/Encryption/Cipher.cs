using System;

namespace ER.Metadata.Decryptor
{
    class Cipher
    {
        private static UInt32[] lpKey = new UInt32[] {
            0xF83DA249, 0x15D12772, 0x40C50697, 0x984E2B6B, 0x14EC5FF8, 0xB2E24927,
            0x3B8F77AE, 0x472474CD, 0x5B0CE524, 0xA17E1A31, 0x6C60852C, 0xD86AD267,
            0x832612B7, 0x1CA03645, 0x5515ABC8, 0xC5FEFF52, 0xFFFFAC00, 0x0FE95CB6,
            0x79CF43DD, 0xAA48A3FB, 0xE1D71788, 0x97663D3A, 0xF5CFFEA7, 0xEE617632,
            0x4B11A7EE, 0x040EF0B5, 0x0606FC00, 0xC1530FAE, 0x7A827441, 0xFCE91D44,
            0x8C4CC1B1, 0x7294C28D, 0x8D976162, 0x8315435A, 0x3917A408, 0xAF7F1327,
            0xD4BFAED7, 0x80D0ABFC, 0x63923DC3, 0xB0E6B35A, 0xB815088F, 0x9BACF123,
            0xE32411C3, 0xA026100B, 0xBCF2FF58, 0x641C5CFC, 0xC4A2D7DC, 0x99E05DCA,
            0x9DC699F7, 0xB76A8621, 0x8E40E03C, 0x28F3C2D4, 0x40F91223, 0x67A952E0,
            0x505F3621, 0xBAF13D33, 0xA75B61CC, 0xAB6AEF54, 0xC4DFB60D, 0xD29D873A,
            0x57A77146, 0x393F86B8, 0x2A734A54, 0x31A56AF6, 0x0C5D9160, 0xAF83A19A,
            0x7FC9B41F, 0xD079EF47, 0xE3295281, 0x5602E3E5, 0xAB915E69, 0x225A1992,
            0xA387F6B2, 0x7E981613, 0xFC6CF59A, 0xD34A7378, 0xB608B7D6, 0xA9EB93D9,
            0x26DDB218, 0x65F33F5F, 0xF9314442, 0x5D5C0599, 0xEA72E774, 0x1605A502,
            0xEC6CBC9F, 0x7F8A1BD1, 0x4DD8CF07, 0x2E6D79E0, 0x6990418F, 0xCF77BAD9,
            0xD4FE0147, 0xFEF4A3E8, 0x85C45BDE, 0xB58F8E67, 0xA63EB8D7, 0xC69BD19B,
            0xDA442DCA, 0x3C0C1743, 0xE6F39D49, 0x33568804, 0x85EB6320, 0xDA223445,
            0x36C4A941, 0xA9185589, 0x71B22D67, 0xF59A2647, 0x3C8B583E, 0xD7717DED,
            0xDF05699C, 0x4378367D, 0x1C459339, 0x85133B7F, 0x49800CE2, 0x3666CA0D,
            0xAF7AB504, 0x4FF5B8F1, 0xC23772E3, 0x3544F31E, 0x0F673A57, 0xF40600E1,
            0x7E967417, 0x15A26203, 0x5F2E34CE, 0x70C7921A, 0xD1C190DF, 0x5BB5DA6B,
            0x60979C75, 0x4EA758A4, 0x078FE359, 0x1664639C, 0xAE14E73B, 0x2070FF03
        };

        public static Byte[] iDecryptData(Byte[] lpBuffer)
        {
            for (Int32 i = 0; i < lpBuffer.Length; i += 4)
            {
                UInt32 dwData = BitConverter.ToUInt32(lpBuffer, 4 * (i >> 2));
                dwData ^= lpKey[(i + (i >> 7)) & 0x7F];

                lpBuffer[i + 0] = (Byte)dwData;
                lpBuffer[i + 1] = (Byte)(dwData >> 8);
                lpBuffer[i + 2] = (Byte)(dwData >> 16);
                lpBuffer[i + 3] = (Byte)(dwData >> 24);
            }

            return lpBuffer;
        }
    }
}
